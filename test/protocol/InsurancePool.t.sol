// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "forge-std/console.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { Setup } from "test/Setup.sol";
import { SimpleReceiverFactory } from "src/dao/emissions/receivers/SimpleReceiverFactory.sol";
import { SimpleReceiver } from "src/dao/emissions/receivers/SimpleReceiver.sol";
import { GovToken } from "src/dao/GovToken.sol";
import { EmissionsController } from "src/dao/emissions/EmissionsController.sol";

contract InsurancePoolTest is Setup {
    uint256 public defaultAmount = 10_000e18;

    function setUp() public override {
        super.setUp();

        stablecoin.approve(address(insurancePool), type(uint256).max);
        deal(address(stablecoin), address(this), defaultAmount);
        vm.prank(address(core));
        insurancePool.setWithdrawTimers(1 days, 1 days);
    }

    function test_SetWithdrawTimers() public {
        uint256 amount = 10_000e18;
        depositSome(amount);
        vm.prank(address(core));
        insurancePool.setWithdrawTimers(1 days, 1 days);

        insurancePool.exit();

        uint256 balance = insurancePool.balanceOf(address(this));
        vm.expectRevert("!withdraw time");
        insurancePool.redeem(
            balance, 
            address(this), 
            address(this)
        );

        skip(1 days);

        uint256 withdrawn = insurancePool.redeem(
            insurancePool.balanceOf(address(this)) / 2, 
            address(this), 
            address(this)
        );
        assertEq(withdrawn, amount / 2);

        skip(1 days);

        insurancePool.exit();
        skip(
            insurancePool.withdrawTime() + 
            insurancePool.withdrawTimeLimit() +
            1
        );

        balance = insurancePool.balanceOf(address(this));
        vm.expectRevert("withdraw time over");
        insurancePool.redeem(
            balance, // Remainder
            address(this), 
            address(this)
        );
        assertGt(insurancePool.balanceOf(address(this)), 0);
    }

    function test_Mint() public {
        uint256 minted = insurancePool.mint(defaultAmount, address(this));
        assertGt(minted, 0);
        assertEq(insurancePool.convertToAssets(minted), defaultAmount);
    }

    function test_WithdrawAndRedeem() public {
        depositSome(defaultAmount);

        insurancePool.exit();

        skip(insurancePool.withdrawTime());

        uint256 shares = insurancePool.balanceOf(address(this));
        uint256 withdrawn = insurancePool.redeem(
            shares, 
            address(this), 
            address(this)
        );
        assertEq(withdrawn, defaultAmount);
        assertEq(insurancePool.balanceOf(address(this)), 0);
        assertEq(insurancePool.convertToAssets(shares), withdrawn);
    }

    function test_Exit() public {
        depositSome(defaultAmount);

        assertEq(insurancePool.withdrawQueue(address(this)), 0);
        insurancePool.exit();
        assertGt(insurancePool.withdrawQueue(address(this)), 0);

        skip(insurancePool.withdrawTime());
        insurancePool.redeem(
            insurancePool.balanceOf(address(this)) / 2,
            address(this),
            address(this)
        );
        assertEq(insurancePool.withdrawQueue(address(this)), 0);

        insurancePool.exit();
        skip(insurancePool.withdrawTime());
        insurancePool.withdraw(
            insurancePool.balanceOf(address(this)),
            address(this),
            address(this)
        );
        assertEq(insurancePool.withdrawQueue(address(this)), 0);
    }

    function test_CancelExit() public {
        depositSome(defaultAmount);

        assertEq(insurancePool.withdrawQueue(address(this)), 0);
        insurancePool.exit();
        assertGt(insurancePool.withdrawQueue(address(this)), 0);
        insurancePool.cancelExit();
        assertEq(insurancePool.withdrawQueue(address(this)), 0);
    }

    function depositSome(uint256 _amount) public {
        uint256 balance = insurancePool.balanceOf(address(this));
        insurancePool.deposit(_amount, address(this));
        assertEq(insurancePool.balanceOf(address(this)), balance + _amount);
    }
}
